/// <reference types="node" />
import { GraphQLResolveInfo } from 'graphql';
import { EventEmitter } from 'events';
export interface ISubscriptionResolver<T = any, R = T> {
    subscribe(source: any, args: any, context: any, info: GraphQLResolveInfo): AsyncIterator<T>;
    resolve(source: any, args: any, context: any, info: GraphQLResolveInfo): R;
}
export interface ISubscriptionEventFilter {
    filterValue(value: any, source: any, args: any, context: any, info: GraphQLResolveInfo): boolean;
}
export interface SubscriptionState {
    done: boolean;
}
export declare abstract class SubscriptionResolverBase<T = any, R = T, S extends SubscriptionState = SubscriptionState> implements ISubscriptionResolver<T, R> {
    subscribe(source: any, args: any, context: any, info: GraphQLResolveInfo): AsyncIterator<T>;
    init(source: any, args: any, context: any, info: GraphQLResolveInfo): S;
    protected abstract next(state: S, source: any, args: any, context: any, info: GraphQLResolveInfo): Promise<IteratorResult<T>>;
    return(state: S, source: any, args: any, context: any, info: GraphQLResolveInfo): Promise<IteratorResult<T>>;
    resolve(source: T, args: any, context: any, info: GraphQLResolveInfo): R;
}
export declare abstract class SubscriptionEventResolverBase<T = any, R = T> implements ISubscriptionResolver<T, R>, ISubscriptionEventFilter {
    abstract eventNames: Array<string>;
    abstract eventEmitter: EventEmitter;
    subscribe(source: any, args: any, context: any, info: any): AsyncIterator<T>;
    filterValue(value: any, source: any, args: any, context: any, info: any): boolean;
    resolve(source: T, args: any, context: any, info: any): R;
}
