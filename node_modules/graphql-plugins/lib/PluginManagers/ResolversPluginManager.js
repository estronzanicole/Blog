"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const zox_plugins_1 = require("zox-plugins");
const TypeDefsPluginManager_1 = require("./TypeDefsPluginManager");
const pluginKey = Symbol('GraphQL Type');
const queriesKey = Symbol('GraphQL Queries');
const mutationsKey = Symbol('GraphQL Mutations');
const fieldsKey = Symbol('GraphQL Fields');
class ResolversPluginManager extends TypeDefsPluginManager_1.TypeDefsPluginManager {
    get pluginKey() {
        return pluginKey;
    }
    getBuild(options) {
        if (this.pluginDefinitions.length == 0) {
            return { typeDef: '', resolvers: {} };
        }
        options = options || {};
        const resolvers = {};
        const queries = {};
        const mutations = {};
        const queryFields = [];
        const mutationFields = [];
        for (const pluginDefinition of this.pluginDefinitions) {
            const pluginClass = pluginDefinition.pluginClass;
            const instance = new pluginClass();
            if (options.decorate) {
                options.decorate(instance);
            }
            const type = pluginDefinition.data.type || pluginClass.name;
            const staticFieldResolvers = pluginClass[fieldsKey];
            const fieldResolvers = pluginClass.prototype[fieldsKey];
            if (staticFieldResolvers || fieldResolvers) {
                const typeResolvers = resolvers[type] = resolvers[type] || {};
                if (staticFieldResolvers) {
                    for (const fieldResolver of staticFieldResolvers) {
                        typeResolvers[fieldResolver.field] = pluginClass[fieldResolver.propertyKey];
                    }
                }
                if (fieldResolvers) {
                    for (const fieldResolver of fieldResolvers) {
                        typeResolvers[fieldResolver.field] = instance[fieldResolver.propertyKey].bind(instance);
                    }
                }
            }
            function readFields(typeResolvers, fieldDefs, fieldList, isInstance) {
                if (fieldList) {
                    for (const fieldDef of fieldList) {
                        const field = fieldDef.field.trim();
                        let name = fieldDef.propertyKey;
                        let prependName = true;
                        let index = field.indexOf('(');
                        if (index >= 0) {
                            const _name = field.substring(0, index).trim();
                            if (_name) {
                                name = _name;
                                prependName = false;
                            }
                        }
                        else {
                            index = field.indexOf(':');
                            if (index >= 0) {
                                const _name = field.substring(0, index).trim();
                                if (_name) {
                                    name = _name;
                                    prependName = false;
                                }
                            }
                        }
                        typeResolvers[name] = isInstance ? instance[fieldDef.propertyKey].bind(instance) : pluginClass[fieldDef.propertyKey];
                        fieldDefs.push(prependName ? field.includes('(') || field.startsWith(':') ? name + field : name + ': ' + field : field);
                    }
                }
            }
            readFields(queries, queryFields, pluginClass[queriesKey]);
            readFields(queries, queryFields, pluginClass.prototype[queriesKey], true);
            readFields(mutations, mutationFields, pluginClass[mutationsKey]);
            readFields(mutations, mutationFields, pluginClass.prototype[mutationsKey], true);
        }
        let typeDef = '';
        if (queryFields.length) {
            resolvers.Query = queries;
            typeDef += `\nextend type Query\n{\n${queryFields.join('\n')}\n}\n`;
        }
        if (mutationFields.length) {
            resolvers.Mutation = mutations;
            typeDef += `\nextend type Mutation\n{\n${mutationFields.join('\n')}\n}\n`;
        }
        return { typeDef, resolvers };
    }
}
exports.ResolversPluginManager = ResolversPluginManager;
function Resolvers(optionsOrClass) {
    if (typeof optionsOrClass === 'function') {
        zox_plugins_1.PluginSetup(pluginKey, { type: optionsOrClass.name })(optionsOrClass);
    }
    else {
        return zox_plugins_1.PluginSetup(pluginKey, optionsOrClass);
    }
}
exports.Resolvers = Resolvers;
function query(field) {
    return function _query(target, propertyKey) {
        requireFunction(target, propertyKey);
        if (!target[queriesKey]) {
            target[queriesKey] = [];
        }
        target[queriesKey].push({ propertyKey, field });
    };
}
exports.query = query;
function mutation(field) {
    return function _mutation(target, propertyKey) {
        requireFunction(target, propertyKey);
        if (!target[mutationsKey]) {
            target[mutationsKey] = [];
        }
        target[mutationsKey].push({ propertyKey, field });
    };
}
exports.mutation = mutation;
function field(fieldOrTarget, propertyKey) {
    const isString = typeof fieldOrTarget === 'string';
    const fieldName = isString ? fieldOrTarget : propertyKey;
    function _field(target, propertyKey) {
        requireFunction(target, propertyKey);
        if (!target[fieldsKey]) {
            target[fieldsKey] = [];
        }
        target[fieldsKey].push({ propertyKey, field: fieldName });
    }
    if (isString) {
        return _field;
    }
    _field(fieldOrTarget, propertyKey);
}
exports.field = field;
function requireFunction(target, propertyKey) {
    if (typeof target[propertyKey] !== 'function') {
        throw new TypeError(`Property '${propertyKey}' on '${target.name}' is not a function`);
    }
}
//# sourceMappingURL=ResolversPluginManager.js.map