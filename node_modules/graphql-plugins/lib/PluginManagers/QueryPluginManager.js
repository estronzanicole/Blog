"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const zox_plugins_1 = require("zox-plugins");
const TypeDefsPluginManager_1 = require("./TypeDefsPluginManager");
const graphql_1 = require("graphql");
const language_1 = require("graphql/language");
const pluginKeyQuery = Symbol('GraphQL Query');
const pluginKeyMutation = Symbol('GraphQL Mutation');
const pluginKeySubscription = Symbol('GraphQL Subscription');
class QueryPluginManagerBase extends TypeDefsPluginManager_1.TypeDefsPluginManager {
    getBuild(options) {
        if (this.pluginDefinitions.length == 0) {
            return { typeDef: '', resolvers: {} };
        }
        options = options || {};
        const resolvers = {};
        const resolverClassNames = {};
        const queries = {};
        for (const pluginDefinition of this.pluginDefinitions) {
            const lexer = language_1.createLexer(new graphql_1.Source(pluginDefinition.data.field), {});
            lexer.advance();
            if (lexer.token.kind !== 'Name') {
                console.error(`Invalid field definition on class ${pluginDefinition.pluginClass.name}`);
                continue;
            }
            const fieldName = lexer.token.value;
            if (resolvers[pluginDefinition.data.field]) {
                console.warn(`Overriding field: ${this.type}.${fieldName}
  new class: ${pluginDefinition.pluginClass.name}
  old class: ${resolverClassNames[fieldName]}
  new query: ${pluginDefinition.data.field}
  old query: ${queries[fieldName]}`);
            }
            const instance = new pluginDefinition.pluginClass();
            if (options.decorate) {
                options.decorate(instance);
            }
            resolvers[fieldName] = this.getResolver(instance);
            queries[fieldName] = pluginDefinition.data.field;
            resolverClassNames[fieldName] = pluginDefinition.pluginClass.name;
        }
        let fieldDefs = '';
        const fieldNames = Object.getOwnPropertyNames(queries);
        for (const field of fieldNames) {
            fieldDefs += queries[field] + '\n';
        }
        return {
            typeDef: `\ntype ${this.type}\n{\n${fieldDefs}}\n`,
            resolvers: { [this.type]: resolvers },
        };
    }
}
exports.QueryPluginManagerBase = QueryPluginManagerBase;
class QueryPluginManager extends QueryPluginManagerBase {
    constructor() {
        super(...arguments);
        this.type = 'Query';
    }
    get pluginKey() {
        return pluginKeyQuery;
    }
    getResolver(instance) {
        return instance.handle.bind(instance);
    }
}
exports.QueryPluginManager = QueryPluginManager;
class MutationPluginManager extends QueryPluginManager {
    constructor() {
        super(...arguments);
        this.type = 'Mutation';
    }
    get pluginKey() {
        return pluginKeyMutation;
    }
}
exports.MutationPluginManager = MutationPluginManager;
class SubscriptionPluginManager extends QueryPluginManagerBase {
    constructor() {
        super(...arguments);
        this.type = 'Subscription';
    }
    get pluginKey() {
        return pluginKeySubscription;
    }
    getResolver(instance) {
        return {
            subscribe: instance.subscribe.bind(instance),
            resolve: instance.resolve.bind(instance),
        };
    }
}
exports.SubscriptionPluginManager = SubscriptionPluginManager;
function Query(field, typeDefs) {
    return zox_plugins_1.PluginSetup(pluginKeyQuery, { field, typeDefs });
}
exports.Query = Query;
function Mutation(field, typeDefs) {
    return zox_plugins_1.PluginSetup(pluginKeyMutation, { field, typeDefs });
}
exports.Mutation = Mutation;
function Subscription(field, typeDefs) {
    return zox_plugins_1.PluginSetup(pluginKeySubscription, { field, typeDefs });
}
exports.Subscription = Subscription;
//# sourceMappingURL=QueryPluginManager.js.map