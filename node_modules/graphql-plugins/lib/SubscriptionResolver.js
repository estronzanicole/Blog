"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const iterall_1 = require("iterall");
class SubscriptionResolverBase {
    subscribe(source, args, context, info) {
        const state = this.init(source, args, context, info);
        return {
            next: this.next.bind(this, state, source, args, context, info),
            return: this.return.bind(this, state, source, args, context, info),
            throw(error) {
                return Promise.reject(error);
            },
            [iterall_1.$$asyncIterator]() {
                return this;
            },
        };
    }
    init(source, args, context, info) {
        return { done: false };
    }
    return(state, source, args, context, info) {
        state.done = true;
        return Promise.resolve({ value: undefined, done: true });
    }
    resolve(source, args, context, info) {
        return source;
    }
}
exports.SubscriptionResolverBase = SubscriptionResolverBase;
class SubscriptionEventResolverBase {
    subscribe(source, args, context, info) {
        const pullQueue = [];
        const pushQueue = [];
        let listening = true;
        const pushValue = event => {
            if (this.filterValue(event, source, args, context, info)) {
                if (pullQueue.length !== 0) {
                    pullQueue.shift()({ value: event, done: false });
                }
                else {
                    pushQueue.push(event);
                }
            }
        };
        const pullValue = () => {
            return new Promise(resolve => {
                if (pushQueue.length !== 0) {
                    resolve({ value: pushQueue.shift(), done: false });
                }
                else {
                    pullQueue.push(resolve);
                }
            });
        };
        const emptyQueue = () => {
            if (listening) {
                listening = false;
                removeEventListeners();
                pullQueue.forEach(resolve => resolve({ value: undefined, done: true }));
                pullQueue.length = 0;
                pushQueue.length = 0;
            }
        };
        const addEventListeners = () => {
            for (const eventName of this.eventNames) {
                this.eventEmitter.addListener(eventName, pushValue);
            }
        };
        const removeEventListeners = () => {
            for (const eventName of this.eventNames) {
                this.eventEmitter.removeListener(eventName, pushValue);
            }
        };
        addEventListeners();
        return {
            next() {
                return listening ? pullValue() : this.return();
            },
            return() {
                emptyQueue();
                return Promise.resolve({ value: undefined, done: true });
            },
            throw(error) {
                emptyQueue();
                return Promise.reject(error);
            },
            [iterall_1.$$asyncIterator]() {
                return this;
            },
        };
    }
    filterValue(value, source, args, context, info) {
        return true;
    }
    resolve(source, args, context, info) {
        return source;
    }
}
exports.SubscriptionEventResolverBase = SubscriptionEventResolverBase;
//# sourceMappingURL=SubscriptionResolver.js.map